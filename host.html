<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WWM Live - Host Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117;
            color: #e6edf3;
            min-height: 100vh;
        }

        /* --- Top Bar --- */
        .top-bar {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .top-bar h1 {
            font-size: 20px;
            color: #ffd700;
        }
        .top-bar .status {
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 14px;
        }
        .top-bar .status .dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }
        .dot.green { background: #3fb950; }
        .dot.red { background: #f85149; }

        /* --- Layout --- */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 0;
            height: calc(100vh - 52px);
        }

        /* --- Main Panel (left) --- */
        .main-panel {
            padding: 20px;
            overflow-y: auto;
        }

        /* --- Sidebar (right) --- */
        .sidebar {
            background: #161b22;
            border-left: 1px solid #30363d;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-section {
            padding: 16px;
            border-bottom: 1px solid #30363d;
        }
        .sidebar-section h3 {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 10px;
        }
        .player-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 16px 16px;
        }

        /* --- Cards --- */
        .card {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }
        .card h2 {
            font-size: 16px;
            color: #ffd700;
            margin-bottom: 14px;
        }

        /* --- Setup Screen --- */
        .setup-card {
            max-width: 500px;
            margin: 40px auto;
            text-align: center;
        }
        #qrcode {
            margin: 20px auto;
            display: inline-block;
            padding: 16px;
            background: white;
            border-radius: 10px;
        }
        .join-url {
            background: #0d1117;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            word-break: break-all;
            color: #58a6ff;
            margin: 12px 0;
        }
        .open-display-btn {
            background: #238636;
            color: #fff;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            margin: 10px 5px;
            font-weight: 600;
        }
        .open-display-btn:hover { background: #2ea043; }
        .top-bar .open-display-btn {
            padding: 6px 14px;
            font-size: 13px;
            margin: 0 0 0 12px;
        }

        /* --- Buttons --- */
        .btn {
            background: linear-gradient(135deg, #ff9800, #ff6f00);
            border: none;
            padding: 12px 28px;
            font-size: 15px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            color: #fff;
            transition: all 0.2s;
            margin: 4px;
        }
        .btn:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(255,152,0,0.3); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn.green { background: #238636; }
        .btn.green:hover:not(:disabled) { background: #2ea043; }
        .btn.red { background: #da3633; }
        .btn.red:hover:not(:disabled) { background: #f85149; }

        /* --- Game Info --- */
        .game-info-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }
        .info-box {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 14px;
            text-align: center;
        }
        .info-box .value {
            font-size: 28px;
            font-weight: bold;
            color: #ffd700;
        }
        .info-box .label {
            font-size: 12px;
            color: #8b949e;
            margin-top: 4px;
        }

        /* --- Question Preview --- */
        .question-preview {
            background: linear-gradient(135deg, #1e3a5f, #2c5282);
            border-radius: 10px;
            padding: 20px;
            font-size: 18px;
            text-align: center;
            margin-bottom: 14px;
        }
        .answers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 14px;
        }
        .answer-item {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 10px 14px;
            font-size: 14px;
        }
        .answer-item .letter {
            color: #ffd700;
            font-weight: bold;
            margin-right: 8px;
        }
        .answer-item.is-correct {
            border-color: #3fb950;
            background: rgba(63, 185, 80, 0.1);
        }

        /* --- Control Buttons --- */
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* --- Results --- */
        .results-list { margin-top: 12px; }
        .result-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 4px;
            font-size: 14px;
        }
        .result-row.correct { background: rgba(63,185,80,0.15); border-left: 3px solid #3fb950; }
        .result-row.wrong { background: rgba(248,81,73,0.15); border-left: 3px solid #f85149; }

        /* --- Player Items --- */
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 4px;
            background: #0d1117;
            border: 1px solid #30363d;
            font-size: 14px;
        }
        .player-item.dead { opacity: 0.5; border-left: 3px solid #f85149; }
        .player-item.alive { border-left: 3px solid #3fb950; }
        .player-item.answered { border-left: 3px solid #ffd700; }
        .badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }
        .badge.alive { background: #238636; }
        .badge.dead { background: #da3633; }
        .badge.answered { background: #9e6a03; color: #fff; }
        .badge.connected { background: #1f6feb; }

        /* --- Sound Panel --- */
        .sound-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        .sound-btn {
            background: #21262d;
            border: 1px solid #30363d;
            color: #e6edf3;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        .sound-btn:hover { background: #30363d; border-color: #58a6ff; }
        .sound-btn.playing { background: #1f6feb; border-color: #58a6ff; }
        .stop-sound-btn {
            grid-column: 1 / -1;
            background: #da3633;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 600;
        }
        .stop-sound-btn:hover { background: #f85149; }
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .volume-control input { flex: 1; }
        .volume-control label { font-size: 12px; color: #8b949e; }

        /* --- Hidden --- */
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1>üéÆ WWM Live ‚Äî Host Dashboard</h1>
        <div class="status">
            <span><span class="dot green" id="peerDot"></span> <span id="peerStatus">Verbinde...</span></span>
            <span>Spieler: <strong id="topPlayerCount">0</strong></span>
            <span>Aktiv: <strong id="topAlivePlayers">0</strong></span>
            <button class="open-display-btn" id="topOpenDisplayBtn">üì∫ Beamer √∂ffnen</button>
        </div>
    </div>

    <div class="dashboard">
        <!-- ===== MAIN PANEL ===== -->
        <div class="main-panel">

            <!-- SETUP -->
            <div id="setupPanel">
                <div class="card setup-card">
                    <h2>Spiel einrichten</h2>
                    <p style="color:#8b949e; margin-bottom:14px;">Spieler scannen den QR-Code oder √∂ffnen den Link:</p>
                    <div id="qrcode"></div>
                    <div class="join-url" id="joinUrl">Warte auf Verbindung...</div>
                    <div>
                        <button class="open-display-btn" id="openDisplayBtn">üì∫ Beamer-Anzeige √∂ffnen</button>
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="btn green" id="startGameBtn" disabled>‚ñ∂ Spiel starten</button>
                    </div>
                    <div style="margin-top: 20px;">
                        <button class="btn" id="debugToggle" style="background:#333;font-size:12px;" onclick="document.getElementById('debugPanel').style.display = document.getElementById('debugPanel').style.display === 'none' ? 'block' : 'none';">Netzwerk-Diagnose anzeigen</button>
                        <div id="debugPanel" style="display:none; margin-top:10px;">
                            <pre id="debugLog" style="background:#0a0a0a; border:1px solid #30363d; border-radius:6px; padding:10px; font-size:11px; max-height:200px; overflow-y:auto; color:#8b949e; text-align:left; white-space:pre-wrap;"></pre>
                            <button class="btn" style="background:#333;font-size:11px;margin-top:6px;" onclick="runNetworkTest();">Netzwerk-Test starten</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- GAME -->
            <div id="gamePanel" class="hidden">
                <div class="game-info-grid">
                    <div class="info-box">
                        <div class="value" id="infoQuestion">1</div>
                        <div class="label">Frage</div>
                    </div>
                    <div class="info-box">
                        <div class="value" id="infoTimer">30</div>
                        <div class="label">Sekunden</div>
                    </div>
                    <div class="info-box">
                        <div class="value" id="infoAlive">0</div>
                        <div class="label">Aktiv</div>
                    </div>
                    <div class="info-box">
                        <div class="value" id="infoPrize">‚Ç¨ 50</div>
                        <div class="label">Gewinnstufe</div>
                    </div>
                </div>

                <div class="card">
                    <h2>Aktuelle Frage</h2>
                    <div class="question-preview" id="dashQuestion">‚Äî</div>
                    <div class="answers-grid" id="dashAnswers"></div>
                    <div class="controls">
                        <button class="btn" id="revealBtn" disabled>üîì Aufl√∂sung zeigen</button>
                        <button class="btn green" id="nextBtn" disabled>‚û° N√§chste Frage</button>
                    </div>
                </div>

                <div class="card" id="resultsCard" style="display:none;">
                    <h2>Ergebnisse dieser Runde</h2>
                    <div class="results-list" id="resultsList"></div>
                </div>
            </div>
        </div>

        <!-- ===== SIDEBAR ===== -->
        <div class="sidebar">
            <!-- Sound Controls -->
            <div class="sidebar-section">
                <h3>üîä Sounds</h3>
                <div class="sound-grid">
                    <button class="sound-btn" data-sound="intro">üé¨ Intro</button>
                    <button class="sound-btn" data-sound="login">üîë Login</button>
                    <button class="sound-btn" data-sound="lvl1">üéµ Level 1</button>
                    <button class="sound-btn" data-sound="lvl2">üéµ Level 2</button>
                    <button class="sound-btn" data-sound="lvl3">üéµ Level 3</button>
                    <button class="sound-btn" data-sound="5050">üéØ 50:50</button>
                    <button class="sound-btn" data-sound="audience">üë• Publikum</button>
                    <button class="sound-btn" data-sound="phone">üìû Telefon</button>
                    <button class="sound-btn" data-sound="correct">‚úÖ Richtig</button>
                    <button class="sound-btn" data-sound="wrong">‚ùå Falsch</button>
                    <button class="sound-btn" data-sound="win">üèÜ Gewinn</button>
                    <button class="sound-btn" data-sound="outro">üé¨ Outro</button>
                    <button class="stop-sound-btn" id="stopSoundBtn">‚èπ Sound stoppen</button>
                </div>
                <div class="volume-control">
                    <label>üîà</label>
                    <input type="range" id="volumeSlider" min="0" max="100" value="80">
                    <label>üîä</label>
                </div>
            </div>

            <!-- Player List -->
            <div class="sidebar-section">
                <h3>Spieler (<span id="sidebarPlayerCount">0</span>)</h3>
            </div>
            <div class="player-list" id="playersList"></div>
        </div>
    </div>

    <script>
        // ===== QUESTIONS =====
        const questions = [
            			// Stufe 1‚Äì5: Sehr einfach
			{ question: "Wie heisst die weibliche Keimzelle?", answers: ["Eizelle", "Spermium", "Embryo", "Hormon"], correct: 0 },
			{ question: "Wie heisst die m√§nnliche Keimzelle?", answers: ["Hormon", "Embryo", "Spermium", "Follikel"], correct: 2 },
			{ question: "Wo w√§chst ein Baby w√§hrend der Schwangerschaft?", answers: ["Geb√§rmutter", "Scheide", "Eileiter", "Eierstock"], correct: 0 },
			{ question: "Wie nennt man die monatliche Blutung bei M√§dchen und Frauen?", answers: ["Eisprung", "Menstruation", "Pubert√§t", "Befruchtung"], correct: 1 },
			{ question: "Was entsteht direkt nach der Befruchtung?", answers: ["Embryo", "Follikel", "Geb√§rmutterschleimhaut", "Eizelle"], correct: 0 },

			// Stufe 6‚Äì10: Mittel
			{ question: "Welche Struktur produziert die Spermien?", answers: ["Samenleiter", "Nebenhoden", "Prostata", "Hoden"], correct: 3 },
			{ question: "Wo reift die Eizelle heran?", answers: ["Geb√§rmutter", "Scheide", "Eileiter", "Eierstock"], correct: 3 },
			{ question: "Welche Aufgabe hat der Eileiter?", answers: ["Eizellen bilden", "Ort der Befruchtung sein", "Hormone produzieren", "Menstruationsblut abf√ºhren"], correct: 1 },
			{ question: "Was passiert mit der Geb√§rmutterschleimhaut ohne Schwangerschaft?", answers: ["Sie bleibt bestehen", "Sie wird dicker", "Sie wird abgestossen", "Sie produziert Hormone"], correct: 2 },
			{ question: "Wie lange k√∂nnen Spermien im K√∂rper der Frau √ºberleben?", answers: ["Nur wenige Minuten", "Etwa 1 Tag", "Bis zu mehreren Tagen", "Mehrere Wochen"], correct: 2 },

			// Stufe 11‚Äì15: Schwer (15 = Million)
			{ question: "Welches Hormon bereitet nach dem Eisprung die Geb√§rmutter auf eine Schwangerschaft vor?", answers: ["Progesteron", "√ñstrogen", "Testosteron", "Insulin"], correct: 0 },
			{ question: "Welche Ver√§nderung zeigt an, dass der Eisprung bereits stattgefunden hat?", answers: ["Beginn der Menstruation", "Abbau der Schleimhaut", "Leichter Anstieg der K√∂rpertemperatur", "Stopp der Hormonproduktion"], correct: 2 },
			{ question: "Welche Reihenfolge beschreibt den Ablauf einer m√∂glichen Schwangerschaft korrekt?", answers: ["Eisprung ‚Üí Befruchtung ‚Üí Einnistung", "Befruchtung ‚Üí Eisprung ‚Üí Menstruation", "Menstruation ‚Üí Eisprung ‚Üí Befruchtung", "Einnistung ‚Üí Befruchtung ‚Üí Eisprung"], correct: 0 },
			{ question: "Warum ist eine Schwangerschaft kurz nach dem Eisprung besonders wahrscheinlich?", answers: ["Weil dann mehrere Eizellen vorhanden sind", "Weil die Geb√§rmutter leer ist", "Weil Eizelle befruchtbar ist und Spermien √ºberleben k√∂nnen", "Weil die Menstruation vorbei ist"], correct: 2 },
			{ question: "Welche Bedingungen m√ºssen gleichzeitig erf√ºllt sein, damit eine Schwangerschaft entstehen kann?", answers: ["Menstruation und Hormone", "Eisprung, befruchtbare Eizelle und lebende Spermien", "Zyklusbeginn und Temperaturanstieg", "Schleimhautabbau und Eisprung"], correct: 1 }
        ];

        const prizeLevels = [
            "‚Ç¨ 50", "‚Ç¨ 100", "‚Ç¨ 200", "‚Ç¨ 300", "‚Ç¨ 500",
            "‚Ç¨ 1.000", "‚Ç¨ 2.000", "‚Ç¨ 4.000", "‚Ç¨ 8.000", "‚Ç¨ 16.000",
            "‚Ç¨ 32.000", "‚Ç¨ 64.000", "‚Ç¨ 125.000", "‚Ç¨ 500.000", "‚Ç¨ 1.000.000"
        ];

        // ===== STATE =====
        let peer, hostId;
        let players = new Map();
        let currentQuestionIndex = 0;
        let gameStarted = false;
        let questionActive = false;
        let timerInterval;
        let timeLeft = 30;

        // ===== BROADCAST CHANNEL (to display.html) =====
        const displayChannel = new BroadcastChannel('wwm-live');

        // Track current display state for re-sync
        let displayState = { phase: 'waiting' }; // waiting, game, gameEnd

        function sendToDisplay(msg) {
            // Track state for sync when display reopens
            if (msg.type === 'joinUrl') {
                displayState.joinUrl = msg.url;
            }
            if (msg.type === 'gameStart') {
                displayState.phase = 'game';
            }
            if (msg.type === 'question') {
                displayState.currentQuestion = msg;
            }
            if (msg.type === 'reveal') {
                displayState.lastReveal = msg;
            }
            if (msg.type === 'gameEnd') {
                displayState.phase = 'gameEnd';
                displayState.gameEndData = msg;
            }
            displayChannel.postMessage(msg);
        }

        // Listen for sync requests from display
        displayChannel.onmessage = function(event) {
            if (event.data && event.data.type === 'requestSync') {
                // Send full current state to display
                if (displayState.joinUrl) {
                    displayChannel.postMessage({ type: 'joinUrl', url: displayState.joinUrl });
                }
                const count = players.size;
                displayChannel.postMessage({ type: 'playerCount', count: count });

                if (displayState.phase === 'game') {
                    displayChannel.postMessage({ type: 'gameStart' });
                    if (displayState.currentQuestion) {
                        // Send question with instant flag (no animation delay needed)
                        displayChannel.postMessage(Object.assign({}, displayState.currentQuestion, { instant: true }));
                    }
                    if (displayState.lastReveal) {
                        displayChannel.postMessage(displayState.lastReveal);
                    }
                } else if (displayState.phase === 'gameEnd' && displayState.gameEndData) {
                    displayChannel.postMessage({ type: 'gameStart' });
                    displayChannel.postMessage(displayState.gameEndData);
                }
            }
        };

        // ===== SOUND SYSTEM =====
        const sounds = {};
        const soundFiles = ['intro','login','lvl1','lvl2','lvl3','5050','audience','phone','correct','wrong','win','outro'];
        let currentSound = null;

        soundFiles.forEach(name => {
            sounds[name] = new Audio('sounds/' + name + '.mp3');
        });

        function playSound(name) {
            stopSound();
            if (sounds[name]) {
                currentSound = sounds[name];
                currentSound.volume = document.getElementById('volumeSlider').value / 100;
                currentSound.currentTime = 0;
                currentSound.play().catch(e => console.log('Sound play error:', e));
                // Highlight button
                document.querySelectorAll('.sound-btn').forEach(b => b.classList.remove('playing'));
                const btn = document.querySelector(`.sound-btn[data-sound="${name}"]`);
                if (btn) btn.classList.add('playing');
                currentSound.onended = () => {
                    document.querySelectorAll('.sound-btn').forEach(b => b.classList.remove('playing'));
                    currentSound = null;
                };
            }
        }

        function stopSound() {
            if (currentSound) {
                currentSound.pause();
                currentSound.currentTime = 0;
                currentSound = null;
            }
            document.querySelectorAll('.sound-btn').forEach(b => b.classList.remove('playing'));
        }

        // Sound button listeners
        document.querySelectorAll('.sound-btn').forEach(btn => {
            btn.addEventListener('click', () => playSound(btn.dataset.sound));
        });
        document.getElementById('stopSoundBtn').addEventListener('click', stopSound);
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            if (currentSound) currentSound.volume = e.target.value / 100;
        });

        // ===== PEERJS =====
        function logDebug(msg) {
            console.log('[WWM Debug]', msg);
            const el = document.getElementById('debugLog');
            if (el) {
                const time = new Date().toLocaleTimeString('de-CH');
                el.textContent += `[${time}] ${msg}\n`;
                el.scrollTop = el.scrollHeight;
            }
        }

        function initPeer() {
            logDebug('PeerJS wird initialisiert...');
            peer = new Peer(null, {
                debug: 2,
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun.relay.metered.ca:80' },
                        { urls: 'turn:global.relay.metered.ca:80', username: 'e8dd65e92f6932f15a6352de', credential: 'kMjCoS/t42AOPQ5N' },
                        { urls: 'turn:global.relay.metered.ca:443', username: 'e8dd65e92f6932f15a6352de', credential: 'kMjCoS/t42AOPQ5N' },
                        { urls: 'turn:global.relay.metered.ca:443?transport=tcp', username: 'e8dd65e92f6932f15a6352de', credential: 'kMjCoS/t42AOPQ5N' }
                    ]
                }
            });

            peer.on('open', function(id) {
                hostId = id;
                logDebug('Peer-ID erhalten: ' + id);
                logDebug('PeerJS Cloud-Server erreichbar!');
                document.getElementById('peerStatus').textContent = 'Verbunden';
                document.getElementById('peerDot').className = 'dot green';
                generateJoinUrl(id);
            });

            peer.on('connection', function(conn) {
                logDebug('Eingehende Verbindung von: ' + conn.peer);
                conn.on('open', function() {
                    logDebug('Verbindung offen mit: ' + conn.peer);
                    conn.on('data', function(data) {
                        logDebug('Daten empfangen von ' + conn.peer + ': ' + data.type);
                        handlePlayerMessage(conn, data);
                    });
                });
                conn.on('close', function() {
                    logDebug('Verbindung geschlossen: ' + conn.peer);
                    removePlayer(conn.peer);
                });
                conn.on('error', function(err) {
                    logDebug('Verbindungsfehler mit ' + conn.peer + ': ' + err);
                });
            });

            peer.on('error', function(err) {
                logDebug('FEHLER: ' + err.type + ' - ' + err.message);
                document.getElementById('peerStatus').textContent = 'Fehler: ' + err.type;
                document.getElementById('peerDot').className = 'dot red';
            });

            peer.on('disconnected', function() {
                logDebug('Vom PeerJS-Server getrennt! Versuche Reconnect...');
                peer.reconnect();
            });
        }

        async function runNetworkTest() {
            logDebug('=== NETZWERK-DIAGNOSE START ===');

            // Test 1: Internet
            try {
                const r = await fetch('https://www.google.com/favicon.ico', { mode: 'no-cors', cache: 'no-store' });
                logDebug('1. Internet: OK');
            } catch(e) {
                logDebug('1. Internet: FEHLER - ' + e.message);
            }

            // Test 2: PeerJS Cloud Server
            try {
                const r = await fetch('https://0.peerjs.com/', { cache: 'no-store' });
                logDebug('2. PeerJS-Server: OK (Status ' + r.status + ')');
            } catch(e) {
                logDebug('2. PeerJS-Server: FEHLER - ' + e.message);
            }

            // Test 3: STUN
            try {
                const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                pc.createDataChannel('test');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => { reject(new Error('Timeout')); }, 5000);
                    pc.onicecandidate = (e) => {
                        if (e.candidate && e.candidate.candidate.indexOf('srflx') !== -1) {
                            clearTimeout(timeout);
                            resolve(e.candidate);
                        }
                    };
                    pc.onicegatheringstatechange = () => {
                        if (pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            reject(new Error('Kein STUN-Kandidat gefunden'));
                        }
                    };
                });
                logDebug('3. STUN (Google): OK - Oeffentliche IP erreichbar');
                pc.close();
            } catch(e) {
                logDebug('3. STUN (Google): FEHLER - ' + e.message);
                logDebug('   -> WebRTC wird evtl. blockiert!');
            }

            // Test 4: TURN
            try {
                const pc = new RTCPeerConnection({ iceServers: [{ urls: 'turn:global.relay.metered.ca:443?transport=tcp', username: 'e8dd65e92f6932f15a6352de', credential: 'kMjCoS/t42AOPQ5N' }] });
                pc.createDataChannel('test');
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => { reject(new Error('Timeout')); }, 5000);
                    pc.onicecandidate = (e) => {
                        if (e.candidate && e.candidate.candidate.indexOf('relay') !== -1) {
                            clearTimeout(timeout);
                            resolve(e.candidate);
                        }
                    };
                    pc.onicegatheringstatechange = () => {
                        if (pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            reject(new Error('Kein TURN-Relay gefunden'));
                        }
                    };
                });
                logDebug('4. TURN-Server: OK - Relay-Verbindung moeglich');
                pc.close();
            } catch(e) {
                logDebug('4. TURN-Server: FEHLER - ' + e.message);
            }

            // Test 5: Peer Status
            if (peer) {
                logDebug('5. Peer-Status: ' + (peer.open ? 'OFFEN' : peer.destroyed ? 'ZERSTOERT' : peer.disconnected ? 'GETRENNT' : 'UNBEKANNT'));
                if (hostId) logDebug('   Host-ID: ' + hostId);
            } else {
                logDebug('5. Peer: Nicht initialisiert!');
            }

            logDebug('=== NETZWERK-DIAGNOSE ENDE ===');
        }

        function generateJoinUrl(id) {
            const joinUrl = `${window.location.origin}${window.location.pathname.replace('host.html', 'player.html')}?host=${id}`;
            document.getElementById('joinUrl').textContent = joinUrl;

            const qrcodeEl = document.getElementById('qrcode');
            qrcodeEl.innerHTML = '';
            try {
                new QRCode(qrcodeEl, {
                    text: joinUrl, width: 200, height: 200,
                    colorDark: '#000000', colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.H
                });
            } catch (e) { console.error('QR error:', e); }

            // Send join URL to display for beamer
            sendToDisplay({ type: 'joinUrl', url: joinUrl });
        }

        // ===== PLAYER MANAGEMENT =====
        function handlePlayerMessage(conn, data) {
            if (data.type === 'join') {
                const player = {
                    id: conn.peer, name: data.name, conn: conn,
                    alive: true, currentAnswer: null,
                    jokers: { fifty: true, audience: true, phone: true },
                    answered: false
                };
                players.set(conn.peer, player);
                updateUI();
                conn.send({ type: 'joined', success: true });
                playSound('login');
            }

            if (data.type === 'answer') {
                const player = players.get(conn.peer);
                if (player) {
                    player.currentAnswer = data.answer;
                    if (player.alive) {
                        player.jokerUsed = data.joker || null;
                        player.jokersUsed = data.jokers || [];
                        player.phoneTarget = data.phoneTarget || null;
                    }
                    player.answered = true;
                    updatePlayersList();
                }
            }

            if (data.type === 'useFiftyFifty') {
                const q = questions[currentQuestionIndex];
                if (q) {
                    const wrongIndices = [0,1,2,3].filter(i => i !== q.correct);
                    const shuffled = wrongIndices.sort(() => Math.random() - 0.5);
                    conn.send({ type: 'fiftyFiftyResponse', wrongAnswers: shuffled.slice(0, 2) });
                }
            }
        }

        function removePlayer(playerId) {
            players.delete(playerId);
            updateUI();
        }

        function updateUI() {
            const count = players.size;
            const alive = Array.from(players.values()).filter(p => p.alive).length;

            document.getElementById('topPlayerCount').textContent = count;
            document.getElementById('topAlivePlayers').textContent = alive;
            document.getElementById('sidebarPlayerCount').textContent = count;
            document.getElementById('startGameBtn').disabled = count === 0;

            if (gameStarted) {
                document.getElementById('infoAlive').textContent = alive;
            }

            sendToDisplay({ type: 'playerCount', count: count });
            updatePlayersList();
        }

        function updatePlayersList() {
            const listEl = document.getElementById('playersList');
            listEl.innerHTML = '';

            players.forEach(player => {
                const div = document.createElement('div');
                div.className = 'player-item';
                if (!gameStarted) {
                    div.classList.add('alive');
                } else if (!player.alive) {
                    div.classList.add('dead');
                } else if (player.answered && questionActive) {
                    div.classList.add('answered');
                } else {
                    div.classList.add('alive');
                }

                let badge = '';
                if (!gameStarted) {
                    badge = '<span class="badge connected">Verbunden</span>';
                } else if (!player.alive) {
                    badge = '<span class="badge dead">Raus</span>';
                } else if (player.answered && questionActive) {
                    badge = '<span class="badge answered">‚úì</span>';
                } else {
                    badge = '<span class="badge alive">Lebt</span>';
                }

                div.innerHTML = `<span>${player.name}</span>${badge}`;
                listEl.appendChild(div);
            });
        }

        function broadcastToPlayers(message) {
            players.forEach(player => {
                if (player.conn && player.conn.open) {
                    player.conn.send(message);
                }
            });
        }

        // ===== GAME FLOW =====
        function startGame() {
            gameStarted = true;
            currentQuestionIndex = 0;

            players.forEach(player => {
                player.alive = true;
                player.jokers = { fifty: true, audience: true, phone: true };
            });

            document.getElementById('setupPanel').classList.add('hidden');
            document.getElementById('gamePanel').classList.remove('hidden');

            broadcastToPlayers({ type: 'gameStart', totalQuestions: questions.length });
            sendToDisplay({ type: 'gameStart' });

            playSound('intro');
            // Wait for intro to finish, then load question
            setTimeout(() => loadQuestion(), 3000);
        }

        function loadQuestion() {
            if (currentQuestionIndex >= questions.length) { endGame(); return; }

            const q = questions[currentQuestionIndex];
            questionActive = true;
            timeLeft = 30;

            players.forEach(player => {
                player.currentAnswer = null;
                player.jokerUsed = null;
                player.jokersUsed = [];
                player.phoneTarget = null;
                player.answered = false;
            });

            // Update dashboard
            document.getElementById('infoQuestion').textContent = currentQuestionIndex + 1;
            document.getElementById('infoTimer').textContent = timeLeft;
            document.getElementById('infoPrize').textContent = prizeLevels[currentQuestionIndex];
            document.getElementById('dashQuestion').textContent = q.question;

            const answersEl = document.getElementById('dashAnswers');
            answersEl.innerHTML = '';
            q.answers.forEach((answer, idx) => {
                const div = document.createElement('div');
                div.className = 'answer-item' + (idx === q.correct ? ' is-correct' : '');
                div.innerHTML = `<span class="letter">${String.fromCharCode(65 + idx)}:</span> ${answer}`;
                answersEl.appendChild(div);
            });

            document.getElementById('resultsCard').style.display = 'none';
            document.getElementById('revealBtn').disabled = false;
            document.getElementById('nextBtn').disabled = true;

            const alive = Array.from(players.values()).filter(p => p.alive).length;

            // Send to display FIRST (animation takes ~3s)
            sendToDisplay({
                type: 'question', questionNumber: currentQuestionIndex + 1,
                question: q.question, answers: q.answers,
                prize: prizeLevels[currentQuestionIndex], activePlayers: alive
            });

            // Auto-play level music
            if (currentQuestionIndex < 5) playSound('lvl1');
            else if (currentQuestionIndex < 10) playSound('lvl2');
            else playSound('lvl3');

            // Delay sending to players + starting timer to sync with display animation
            // Display animation: 600ms * (4 answers + 1) = 3000ms
            const animationDelay = 600 * (q.answers.length + 1);

            setTimeout(() => {
                const alivePlayers = Array.from(players.values())
                    .filter(p => p.alive).map(p => ({ id: p.id, name: p.name }));

                broadcastToPlayers({
                    type: 'question', questionNumber: currentQuestionIndex + 1,
                    question: q.question, answers: q.answers,
                    prize: prizeLevels[currentQuestionIndex], alivePlayers: alivePlayers
                });

                updateUI();
                startTimer();
            }, animationDelay);
        }

        function startTimer() {
            clearInterval(timerInterval);
            const timerEl = document.getElementById('infoTimer');

            timerInterval = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    // Auto-reveal when timer expires
                    revealAnswer();
                }
            }, 1000);
        }

        function revealAnswer() {
            clearInterval(timerInterval);
            questionActive = false;
            stopSound();

            broadcastToPlayers({ type: 'timerStop' });
            sendToDisplay({ type: 'timerStop' });

            const q = questions[currentQuestionIndex];
            const correctAnswer = q.correct;
            const results = [];

            players.forEach(player => {
                if (!player.alive) {
                    results.push({ name: player.name, status: 'dead', answer: '-', correct: false });
                    return;
                }
                if (!player.answered) {
                    player.alive = false;
                    results.push({ name: player.name, status: 'timeout', answer: 'Keine Antwort', correct: false });
                    return;
                }

                let isCorrect = false, explanation = '';
                const usedJokers = player.jokersUsed || (player.jokerUsed ? [player.jokerUsed] : []);
                const usedAudience = usedJokers.includes('audience');
                const usedPhone = usedJokers.includes('phone');
                const usedFifty = usedJokers.includes('fifty');

                if (usedAudience) {
                    const ownCorrect = player.currentAnswer === correctAnswer;
                    const aliveAnswers = Array.from(players.values())
                        .filter(p => p.alive && p.answered && p.id !== player.id)
                        .map(p => p.currentAnswer);
                    let majorityCorrect = false;
                    if (aliveAnswers.length > 0) {
                        const counts = [0,0,0,0];
                        aliveAnswers.forEach(a => counts[a]++);
                        majorityCorrect = counts.indexOf(Math.max(...counts)) === correctAnswer;
                    }
                    isCorrect = ownCorrect || majorityCorrect;
                    if (ownCorrect && majorityCorrect) explanation = '(Publikum + Eigene ‚úì)';
                    else if (ownCorrect) explanation = '(Eigene Antwort ‚úì)';
                    else if (majorityCorrect) explanation = '(Mehrheit hat gerettet!)';
                    else explanation = '(Beides falsch)';
                } else if (usedPhone && player.phoneTarget) {
                    const target = players.get(player.phoneTarget);
                    if (target && target.alive && target.answered) {
                        if (target.currentAnswer === correctAnswer) {
                            isCorrect = true;
                            explanation = `(üìû ${target.name} ‚úì)`;
                        } else {
                            isCorrect = player.currentAnswer === correctAnswer;
                            explanation = `(üìû Eigene Wahl)`;
                        }
                    } else {
                        isCorrect = player.currentAnswer === correctAnswer;
                        explanation = '(üìû Nicht verf√ºgbar)';
                    }
                } else {
                    isCorrect = player.currentAnswer === correctAnswer;
                    if (usedFifty) explanation = '(50:50)';
                }

                if (!isCorrect) player.alive = false;

                results.push({
                    name: player.name,
                    status: isCorrect ? 'correct' : 'wrong',
                    answer: String.fromCharCode(65 + player.currentAnswer),
                    correct: isCorrect,
                    explanation: explanation
                });
            });

            // Play correct/wrong sound
            const anyCorrect = results.some(r => r.correct);
            playSound(anyCorrect ? 'correct' : 'wrong');

            // Display results in dashboard
            displayResults(results, correctAnswer);

            const alive = Array.from(players.values()).filter(p => p.alive).length;

            broadcastToPlayers({ type: 'reveal', correctAnswer: correctAnswer, results: results });
            sendToDisplay({ type: 'reveal', correctAnswer: correctAnswer, activePlayers: alive });

            updateUI();

            document.getElementById('revealBtn').disabled = true;
            document.getElementById('nextBtn').disabled = false;
        }

        function displayResults(results, correctAnswer) {
            document.getElementById('resultsCard').style.display = 'block';
            const listEl = document.getElementById('resultsList');
            listEl.innerHTML = '';

            results.forEach(result => {
                if (result.status === 'dead') return; // Skip already-dead
                const div = document.createElement('div');
                div.className = `result-row ${result.correct ? 'correct' : 'wrong'}`;
                let icon = result.status === 'timeout' ? '‚è∞' : (result.correct ? '‚úì' : '‚úó');
                div.innerHTML = `<span><strong>${result.name}</strong> ‚Üí ${result.answer} ${result.explanation || ''}</span><span>${icon}</span>`;
                listEl.appendChild(div);
            });
        }

        function nextQuestion() {
            currentQuestionIndex++;
            loadQuestion();
        }

        function endGame() {
            const winners = Array.from(players.values()).filter(p => p.alive);
            const prize = winners.length > 0 ? prizeLevels[Math.min(currentQuestionIndex, prizeLevels.length - 1)] : null;

            playSound(winners.length > 0 ? 'win' : 'outro');

            // Update dashboard
            document.getElementById('dashQuestion').textContent = winners.length > 0
                ? `üéâ Gewinner: ${winners.map(w => w.name).join(', ')} ‚Äî ${prize}`
                : 'Spiel beendet ‚Äî Niemand hat es geschafft!';
            document.getElementById('dashAnswers').innerHTML = '';
            document.getElementById('revealBtn').disabled = true;
            document.getElementById('nextBtn').disabled = true;

            const stats = {
                totalPlayers: players.size,
                survivors: winners.length,
                questionsAsked: currentQuestionIndex
            };

            broadcastToPlayers({
                type: 'gameEnd',
                winners: winners.map(w => w.name),
                prize: prize
            });

            sendToDisplay({
                type: 'gameEnd',
                winners: winners.map(w => w.name),
                prize: prize,
                totalPlayers: stats.totalPlayers,
                survivors: stats.survivors,
                questionsAsked: stats.questionsAsked
            });
        }

        // ===== EVENT LISTENERS =====
        document.getElementById('startGameBtn').addEventListener('click', startGame);
        document.getElementById('revealBtn').addEventListener('click', revealAnswer);
        document.getElementById('nextBtn').addEventListener('click', nextQuestion);
        document.getElementById('openDisplayBtn').addEventListener('click', openDisplayWindow);
        document.getElementById('topOpenDisplayBtn').addEventListener('click', openDisplayWindow);

        function openDisplayWindow() {
            window.open('display.html', 'wwm-display', 'width=1920,height=1080');
        }

        // ===== INIT =====
        initPeer();
    </script>
</body>
</html>
